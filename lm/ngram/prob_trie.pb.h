// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: prob_trie.proto

#ifndef PROTOBUF_prob_5ftrie_2eproto__INCLUDED
#define PROTOBUF_prob_5ftrie_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace lm {
namespace ngram {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_prob_5ftrie_2eproto();
void protobuf_AssignDesc_prob_5ftrie_2eproto();
void protobuf_ShutdownFile_prob_5ftrie_2eproto();

class Node;
class Node_Child;
class ProbTrieProto;

// ===================================================================

class ProbTrieProto : public ::google::protobuf::Message {
 public:
  ProbTrieProto();
  virtual ~ProbTrieProto();

  ProbTrieProto(const ProbTrieProto& from);

  inline ProbTrieProto& operator=(const ProbTrieProto& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProbTrieProto& default_instance();

  void Swap(ProbTrieProto* other);

  // implements Message ----------------------------------------------

  inline ProbTrieProto* New() const { return New(NULL); }

  ProbTrieProto* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProbTrieProto& from);
  void MergeFrom(const ProbTrieProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ProbTrieProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 n = 1;
  void clear_n();
  static const int kNFieldNumber = 1;
  ::google::protobuf::int32 n() const;
  void set_n(::google::protobuf::int32 value);

  // optional .lm.ngram.Node root = 2;
  bool has_root() const;
  void clear_root();
  static const int kRootFieldNumber = 2;
  const ::lm::ngram::Node& root() const;
  ::lm::ngram::Node* mutable_root();
  ::lm::ngram::Node* release_root();
  void set_allocated_root(::lm::ngram::Node* root);

  // @@protoc_insertion_point(class_scope:lm.ngram.ProbTrieProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::lm::ngram::Node* root_;
  ::google::protobuf::int32 n_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_prob_5ftrie_2eproto();
  friend void protobuf_AssignDesc_prob_5ftrie_2eproto();
  friend void protobuf_ShutdownFile_prob_5ftrie_2eproto();

  void InitAsDefaultInstance();
  static ProbTrieProto* default_instance_;
};
// -------------------------------------------------------------------

class Node_Child : public ::google::protobuf::Message {
 public:
  Node_Child();
  virtual ~Node_Child();

  Node_Child(const Node_Child& from);

  inline Node_Child& operator=(const Node_Child& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Node_Child& default_instance();

  void Swap(Node_Child* other);

  // implements Message ----------------------------------------------

  inline Node_Child* New() const { return New(NULL); }

  Node_Child* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Node_Child& from);
  void MergeFrom(const Node_Child& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Node_Child* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // optional .lm.ngram.Node node = 2;
  bool has_node() const;
  void clear_node();
  static const int kNodeFieldNumber = 2;
  const ::lm::ngram::Node& node() const;
  ::lm::ngram::Node* mutable_node();
  ::lm::ngram::Node* release_node();
  void set_allocated_node(::lm::ngram::Node* node);

  // @@protoc_insertion_point(class_scope:lm.ngram.Node.Child)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::lm::ngram::Node* node_;
  ::google::protobuf::int32 id_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_prob_5ftrie_2eproto();
  friend void protobuf_AssignDesc_prob_5ftrie_2eproto();
  friend void protobuf_ShutdownFile_prob_5ftrie_2eproto();

  void InitAsDefaultInstance();
  static Node_Child* default_instance_;
};
// -------------------------------------------------------------------

class Node : public ::google::protobuf::Message {
 public:
  Node();
  virtual ~Node();

  Node(const Node& from);

  inline Node& operator=(const Node& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Node& default_instance();

  void Swap(Node* other);

  // implements Message ----------------------------------------------

  inline Node* New() const { return New(NULL); }

  Node* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Node& from);
  void MergeFrom(const Node& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Node* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Node_Child Child;

  // accessors -------------------------------------------------------

  // optional double pseudo_prob = 1;
  void clear_pseudo_prob();
  static const int kPseudoProbFieldNumber = 1;
  double pseudo_prob() const;
  void set_pseudo_prob(double value);

  // optional double backoff = 2;
  void clear_backoff();
  static const int kBackoffFieldNumber = 2;
  double backoff() const;
  void set_backoff(double value);

  // repeated .lm.ngram.Node.Child child = 3;
  int child_size() const;
  void clear_child();
  static const int kChildFieldNumber = 3;
  const ::lm::ngram::Node_Child& child(int index) const;
  ::lm::ngram::Node_Child* mutable_child(int index);
  ::lm::ngram::Node_Child* add_child();
  ::google::protobuf::RepeatedPtrField< ::lm::ngram::Node_Child >*
      mutable_child();
  const ::google::protobuf::RepeatedPtrField< ::lm::ngram::Node_Child >&
      child() const;

  // @@protoc_insertion_point(class_scope:lm.ngram.Node)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  double pseudo_prob_;
  double backoff_;
  ::google::protobuf::RepeatedPtrField< ::lm::ngram::Node_Child > child_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_prob_5ftrie_2eproto();
  friend void protobuf_AssignDesc_prob_5ftrie_2eproto();
  friend void protobuf_ShutdownFile_prob_5ftrie_2eproto();

  void InitAsDefaultInstance();
  static Node* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// ProbTrieProto

// optional int32 n = 1;
inline void ProbTrieProto::clear_n() {
  n_ = 0;
}
inline ::google::protobuf::int32 ProbTrieProto::n() const {
  // @@protoc_insertion_point(field_get:lm.ngram.ProbTrieProto.n)
  return n_;
}
inline void ProbTrieProto::set_n(::google::protobuf::int32 value) {
  
  n_ = value;
  // @@protoc_insertion_point(field_set:lm.ngram.ProbTrieProto.n)
}

// optional .lm.ngram.Node root = 2;
inline bool ProbTrieProto::has_root() const {
  return !_is_default_instance_ && root_ != NULL;
}
inline void ProbTrieProto::clear_root() {
  if (GetArenaNoVirtual() == NULL && root_ != NULL) delete root_;
  root_ = NULL;
}
inline const ::lm::ngram::Node& ProbTrieProto::root() const {
  // @@protoc_insertion_point(field_get:lm.ngram.ProbTrieProto.root)
  return root_ != NULL ? *root_ : *default_instance_->root_;
}
inline ::lm::ngram::Node* ProbTrieProto::mutable_root() {
  
  if (root_ == NULL) {
    root_ = new ::lm::ngram::Node;
  }
  // @@protoc_insertion_point(field_mutable:lm.ngram.ProbTrieProto.root)
  return root_;
}
inline ::lm::ngram::Node* ProbTrieProto::release_root() {
  // @@protoc_insertion_point(field_release:lm.ngram.ProbTrieProto.root)
  
  ::lm::ngram::Node* temp = root_;
  root_ = NULL;
  return temp;
}
inline void ProbTrieProto::set_allocated_root(::lm::ngram::Node* root) {
  delete root_;
  root_ = root;
  if (root) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:lm.ngram.ProbTrieProto.root)
}

// -------------------------------------------------------------------

// Node_Child

// optional int32 id = 1;
inline void Node_Child::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 Node_Child::id() const {
  // @@protoc_insertion_point(field_get:lm.ngram.Node.Child.id)
  return id_;
}
inline void Node_Child::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:lm.ngram.Node.Child.id)
}

// optional .lm.ngram.Node node = 2;
inline bool Node_Child::has_node() const {
  return !_is_default_instance_ && node_ != NULL;
}
inline void Node_Child::clear_node() {
  if (GetArenaNoVirtual() == NULL && node_ != NULL) delete node_;
  node_ = NULL;
}
inline const ::lm::ngram::Node& Node_Child::node() const {
  // @@protoc_insertion_point(field_get:lm.ngram.Node.Child.node)
  return node_ != NULL ? *node_ : *default_instance_->node_;
}
inline ::lm::ngram::Node* Node_Child::mutable_node() {
  
  if (node_ == NULL) {
    node_ = new ::lm::ngram::Node;
  }
  // @@protoc_insertion_point(field_mutable:lm.ngram.Node.Child.node)
  return node_;
}
inline ::lm::ngram::Node* Node_Child::release_node() {
  // @@protoc_insertion_point(field_release:lm.ngram.Node.Child.node)
  
  ::lm::ngram::Node* temp = node_;
  node_ = NULL;
  return temp;
}
inline void Node_Child::set_allocated_node(::lm::ngram::Node* node) {
  delete node_;
  node_ = node;
  if (node) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:lm.ngram.Node.Child.node)
}

// -------------------------------------------------------------------

// Node

// optional double pseudo_prob = 1;
inline void Node::clear_pseudo_prob() {
  pseudo_prob_ = 0;
}
inline double Node::pseudo_prob() const {
  // @@protoc_insertion_point(field_get:lm.ngram.Node.pseudo_prob)
  return pseudo_prob_;
}
inline void Node::set_pseudo_prob(double value) {
  
  pseudo_prob_ = value;
  // @@protoc_insertion_point(field_set:lm.ngram.Node.pseudo_prob)
}

// optional double backoff = 2;
inline void Node::clear_backoff() {
  backoff_ = 0;
}
inline double Node::backoff() const {
  // @@protoc_insertion_point(field_get:lm.ngram.Node.backoff)
  return backoff_;
}
inline void Node::set_backoff(double value) {
  
  backoff_ = value;
  // @@protoc_insertion_point(field_set:lm.ngram.Node.backoff)
}

// repeated .lm.ngram.Node.Child child = 3;
inline int Node::child_size() const {
  return child_.size();
}
inline void Node::clear_child() {
  child_.Clear();
}
inline const ::lm::ngram::Node_Child& Node::child(int index) const {
  // @@protoc_insertion_point(field_get:lm.ngram.Node.child)
  return child_.Get(index);
}
inline ::lm::ngram::Node_Child* Node::mutable_child(int index) {
  // @@protoc_insertion_point(field_mutable:lm.ngram.Node.child)
  return child_.Mutable(index);
}
inline ::lm::ngram::Node_Child* Node::add_child() {
  // @@protoc_insertion_point(field_add:lm.ngram.Node.child)
  return child_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::lm::ngram::Node_Child >*
Node::mutable_child() {
  // @@protoc_insertion_point(field_mutable_list:lm.ngram.Node.child)
  return &child_;
}
inline const ::google::protobuf::RepeatedPtrField< ::lm::ngram::Node_Child >&
Node::child() const {
  // @@protoc_insertion_point(field_list:lm.ngram.Node.child)
  return child_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ngram
}  // namespace lm

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_prob_5ftrie_2eproto__INCLUDED
